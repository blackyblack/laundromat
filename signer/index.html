<!DOCTYPE html>
<html dir="ltr" lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">

  <title>ETH</title>

</head>

<script type="text/javascript" src="jsbn.js"></script>

<script>

  var cache = [
  '',
  ' ',
  '  ',
  '   ',
  '    ',
  '     ',
  '      ',
  '       ',
  '        ',
  '         '
];

function leftPad (str, len, ch) {
  // convert `str` to `string`
  str = str + '';
  // `len` is the `pad`'s length now
  len = len - str.length;
  // doesn't need to pad
  if (len <= 0) return str;
  // `ch` defaults to `' '`
  if (!ch && ch !== 0) ch = ' ';
  // convert `ch` to `string`
  ch = ch + '';
  // cache common use cases
  if (ch === ' ' && len < 10) return cache[len] + str;
  // `pad` starts with an empty string
  var pad = '';
  // loop
  while (true) {
    // add `ch` to `pad` if `len` is odd
    if (len & 1) pad += ch;
    // divide `len` by 2, ditch the remainder
    len >>= 1;
    // "double" the `ch` so this operation count grows logarithmically on `len`
    // each time `ch` is "doubled", the `len` would need to be "doubled" too
    // similar to finding a value in binary search tree, hence O(log(n))
    if (len) ch += ch;
    // `len` is 0, exit the loop
    else break;
  }
  // pad `str`!
  return pad + str;
}

  // the size of a character in a hex string in bytes
const HEX_CHAR_SIZE = 4

// the size to hash an integer if not explicity provided
const DEFAULT_SIZE = 256

// Encodes a value in hex and adds padding to the given size if needed. Tries to determine whether it should be encoded as a number or string. Curried args. */
function encodeWithPadding(size, value) {
  var web3 = new Web3();
  return typeof value === 'string'
    // non-hex string
    ? web3.toHex(value)
    // numbers, big numbers, and hex strings
    : encodeNum(size, value)
}

// Encodes a number in hex and adds padding to the given size if needed. Curried args. */
function encodeNum(size, value) {
  var web3 = new Web3();
  return leftPad(web3.toHex(value < 0 ? value >>> 0 : value).slice(2), size / HEX_CHAR_SIZE, value < 0 ? 'F' : '0')
}

// Hashes one or more arguments, using a default size for numbers. */
function sha3(array) {
  var web3 = new Web3();
  var paddedArgs = '';
  for(var index = 0; index < array.length; index++) {
    paddedArgs += encodeWithPadding(DEFAULT_SIZE, array[index]);
  }
  //const paddedArgs = args.map(encodeWithPadding(DEFAULT_SIZE)).join('')
  return web3.toBigNumber(web3.sha3(paddedArgs, { encoding: 'hex' }));
}

var B = new jsbn.BigInteger('7');
var P = new jsbn.BigInteger('115792089237316195423570985008687907853269984665640564039457584007908834671663');
var M = new jsbn.BigInteger('57896044618658097711785492504343953926634992332820282019728792003956564819968');
var N = new jsbn.BigInteger('115792089237316195423570985008687907852837564279074904382605163141518161494337');
var Gx = new jsbn.BigInteger('55066263022277343669578718895168534326250603453777594175500187360389116729240');
var Gy = new jsbn.BigInteger('32670510020758816978083085130507043184471273380659243275938904335757337482424');

function to_jacobian(p) {
  var o = [p[0], p[1], jsbn.BigInteger.ONE];
  return o;
}

function jacobian_double(p) {

  var BigInteger = jsbn.BigInteger;

  if(p[1].equals(BigInteger.ZERO)) return [BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO];

  //ysq = (p[1] ** 2) % P
  var ysq = p[1].modPow(new BigInteger('2'), P).add(P).remainder(P);
  //S = (4 * p[0] * ysq) % P
  var S = p[0].multiply(new BigInteger('4')).multiply(ysq).remainder(P).add(P).remainder(P);
  //M = (3 * p[0] ** 2 + A * p[2] ** 4) % P
  var M = p[0].multiply(new BigInteger('3')).multiply(p[0]).remainder(P).add(P).remainder(P);
  //nx = (M**2 - 2 * S) % P
  var nx = M.multiply(M).subtract(S.multiply(new BigInteger('2'))).remainder(P).add(P).remainder(P);
  //ny = (M * (S - nx) - 8 * ysq ** 2) % P
  var ny = M.multiply(S.subtract(nx)).subtract(ysq.multiply(ysq).multiply(new BigInteger('8'))).remainder(P).add(P).remainder(P);
  //nz = (2 * p[1] * p[2]) % P
  var nz = p[1].multiply(p[2]).multiply(new BigInteger('2')).remainder(P).add(P).remainder(P);
  return [nx, ny, nz];
}

function jacobian_add(p, q) {

  var BigInteger = jsbn.BigInteger;

  if(p[1].equals(BigInteger.ZERO)) return q;
  if(q[1].equals(BigInteger.ZERO)) return p;

  //U1 = (p[0] * q[2] ** 2) % P
  var U1 = p[0].multiply(q[2]).multiply(q[2]).remainder(P).add(P).remainder(P);
  //U2 = (q[0] * p[2] ** 2) % P
  var U2 = q[0].multiply(p[2]).multiply(p[2]).remainder(P).add(P).remainder(P);
  //S1 = (p[1] * q[2] ** 3) % P
  var S1 = p[1].multiply(q[2]).multiply(q[2]).multiply(q[2]).remainder(P).add(P).remainder(P);
  //S2 = (q[1] * p[2] ** 3) % P
  var S2 = q[1].multiply(p[2]).multiply(p[2]).multiply(p[2]).remainder(P).add(P).remainder(P);

  if(U1.equals(U2)) {

    if(!S1.equals(S2)) return [BigInteger.ZERO, BigInteger.ZERO, BigInteger.ONE];
    return jacobian_double(p);
  }
    
  //H = U2 - U1
  var H = U2.subtract(U1).remainder(P).add(P).remainder(P);
  //R = S2 - S1
  var R = S2.subtract(S1).remainder(P).add(P).remainder(P);
  //H2 = (H * H) % P
  var H2 = H.multiply(H).remainder(P).add(P).remainder(P);
  //H3 = (H * H2) % P
  var H3 = H.multiply(H2).remainder(P).add(P).remainder(P);
  //U1H2 = (U1 * H2) % P
  var U1H2 = U1.multiply(H2).remainder(P).add(P).remainder(P);
  //nx = (R ** 2 - H3 - 2 * U1H2) % P
  var nx = R.multiply(R).remainder(P).add(P).remainder(P);
  nx = nx.subtract(H3).remainder(P).add(P).remainder(P);
  nx = nx.subtract(U1H2.multiply(new BigInteger('2'))).remainder(P).add(P).remainder(P);;
  //ny = (R * (U1H2 - nx) - S1 * H3) % P
  var ny = U1H2.subtract(nx).remainder(P).add(P).remainder(P);
  ny = ny.multiply(R).remainder(P).add(P).remainder(P);
  ny = ny.subtract(S1.multiply(H3)).remainder(P).add(P).remainder(P);
  //nz = (H * p[2] * q[2]) % P
  var nz = H.multiply(p[2]).multiply(q[2]).remainder(P).add(P).remainder(P);
  return [nx, ny, nz];
}

function jacobian_multiply(a, n) {

  var BigInteger = jsbn.BigInteger;

  if(a[1].equals(BigInteger.ZERO) || n.equals(BigInteger.ZERO))
    return [BigInteger.ZERO, BigInteger.ZERO, BigInteger.ONE];

  if(n.equals(BigInteger.ONE)) return a;

  if((n.compareTo(BigInteger.ZERO) < 0) || (n.compareTo(N) > 0))
    return jacobian_multiply(a, n.remainder(N));

  if(n.isEven())
    return jacobian_double(jacobian_multiply(a, n.divide(new BigInteger('2'))));

  return jacobian_add(jacobian_double(jacobian_multiply(a, n.divide(new BigInteger('2')))), a);
}

function hash_to_pubkey(a) {

  var web3 = new Web3();
  var BigInteger = jsbn.BigInteger;

  var x = sha3([web3.toBigNumber(a[0].toString()), web3.toBigNumber(a[1].toString())]);
  x = new BigInteger('' + x.toFixed());

  while(true) {
    //xcubedaxb = (x*x*x+A*x+B) % P
    var xcubedaxb = ((x.multiply(x.multiply(x))).add(B)).remainder(P).add(P).remainder(P);
    //beta = pow(xcubedaxb, (P+1)//4, P)
    var beta = xcubedaxb.modPow(P.add(BigInteger.ONE).divide(new BigInteger('4')), P).add(P).remainder(P);
    var y = beta;
    if(beta.remainder(new BigInteger('2')).equals(BigInteger.ZERO)) {
      y = P.subtract(beta).add(P).remainder(P);
    }

    if(xcubedaxb.subtract(y.multiply(y)).remainder(P).equals(BigInteger.ZERO)) {
      return [x, y];
    }

    x = x.add(BigInteger.ONE).remainder(P).add(P).remainder(P);
  }
}

function jdecompose(Q) {

  var BigInteger = jsbn.BigInteger;
  //uint ox = mulmod(_q0, jexp(_q2, P - 3, P), P);
  var ox = Q[2].modPow(P.subtract(new BigInteger('3')), P).multiply(Q[0]).remainder(P).add(P).remainder(P);
  //uint oy = mulmod(_q1, jexp(_q2, P - 4, P), P);
  var oy = Q[2].modPow(P.subtract(new BigInteger('4')), P).multiply(Q[1]).remainder(P).add(P).remainder(P);
  return [ox, oy];
}

  function init() {
 
    var web3 = new Web3();

    var privkey = new jsbn.BigInteger("100");
    var myindex = 0;
    var pubkeys = [
      [new jsbn.BigInteger('107303582290733097924842193972465022053148211775194373671539518313500194639752'),
       new jsbn.BigInteger('103795966108782717446806684023742168462365449272639790795591544606836007446638')],

      [new jsbn.BigInteger('92883563547733953747193399241467975295201508608352798513009429659680796014075'),
       new jsbn.BigInteger('114610965210433134803810343179237635280663098111701848326472592228175073260197')]
    ];
    var msghash = new jsbn.BigInteger('300');

    //I = multiply(hash_to_pubkey(my_pub), mypriv)
    var I = jdecompose(jacobian_multiply(to_jacobian(hash_to_pubkey(pubkeys[myindex])), privkey));
    console.log("I = " + I.toString());

    //random key
    var k = new jsbn.BigInteger('400');

    //empty ring
    var e = [];
    for(var i = 0; i < pubkeys.length; i++) {
      e.push([jsbn.BigInteger.ZERO, jsbn.BigInteger.ZERO]);
    }

    var kpub = jdecompose(jacobian_multiply([Gx, Gy, jsbn.BigInteger.ONE], k));
    console.log("kpub = " + kpub.toString());

    //kmulpub =  multiply(hash_to_pubkey(my_pub), k)
    var kmulpub = jdecompose(jacobian_multiply(to_jacobian(hash_to_pubkey(pubkeys[myindex])), k));
    console.log("kmulpub = " + kmulpub.toString());

    //hash together [msghash, kpub[0], kpub[1], kmulpub[0], kmulpub[1]]
    var orig_left = sha3([
      web3.toBigNumber(msghash.toString()),
      web3.toBigNumber(kpub[0].toString()),
      web3.toBigNumber(kpub[1].toString()),
      web3.toBigNumber(kmulpub[0].toString()),
      web3.toBigNumber(kmulpub[1].toString())]);

    console.log("orig_left = " + orig_left.toFixed());

    var orig_right = sha3([orig_left]);

    console.log("orig_right = " + orig_right.toFixed());

    e[myindex] = [
      new jsbn.BigInteger('' + orig_left.toFixed()),
      new jsbn.BigInteger('' + orig_right.toFixed())];

    var signature = [];
    var left = jsbn.BigInteger.ZERO;
    var right = jsbn.BigInteger.ZERO;
    for(var i = 0; i < pubkeys.length; i++) {

      var prev_i = (i + myindex) % pubkeys.length;
      var cur_i = (i + myindex + 1) % pubkeys.length;

      if(cur_i == myindex) {

        var s0 = e[prev_i][1].multiply(privkey).add(k).remainder(N).add(N).remainder(N);
        signature[prev_i] = s0;
      } else {

        //random key
        var s0 = new jsbn.BigInteger('500');
        signature[prev_i] = s0;
      }

      console.log("s0 = " + signature[prev_i].toString());

      //pub1 = b.subtract_pubkeys(b.privtopub(s[prev_i]),
      //                            b.multiply(pubs[i], e[prev_i]["right"]))
      var pubx = jdecompose(jacobian_multiply([Gx, Gy, jsbn.BigInteger.ONE], signature[prev_i]));
      console.log("pubx = " + pubx.toString());

      var jmul1 = jacobian_multiply(to_jacobian(pubkeys[cur_i]), e[prev_i][1]);
      jmul1[1] = P.subtract(jmul1[1]);

      var pub1 = jdecompose(jacobian_add(to_jacobian(pubx), jmul1));
      console.log("pub1 = " + pub1.toString());

      var kmulpub1 = jacobian_multiply(to_jacobian(hash_to_pubkey(pubkeys[cur_i])), signature[prev_i]);
      console.log("kmulpub1 = " + jdecompose(kmulpub1).toString());

      var Imul1 = jacobian_multiply(to_jacobian(I), e[prev_i][1]);
      Imul1[1] = P.subtract(Imul1[1]);

      var pub2 = jdecompose(jacobian_add(kmulpub1, Imul1));
      console.log("pub2 = " + pub2.toString());

      //hash together [msghash, kpub[0], kpub[1], kmulpub[0], kmulpub[1]]
      left = sha3([
        web3.toBigNumber(msghash.toString()),
        web3.toBigNumber(pub1[0].toString()),
        web3.toBigNumber(pub1[1].toString()),
        web3.toBigNumber(pub2[0].toString()),
        web3.toBigNumber(pub2[1].toString())]);

      console.log("left = " + left.toFixed());

      right = sha3([left]);
      console.log("right = " + right.toFixed());

      e[cur_i] = [
        new jsbn.BigInteger('' + left.toFixed()),
        new jsbn.BigInteger('' + right.toFixed())];
    }

    if(!left.equals(orig_left)) {
      console.log("Signature failed!");
      return;
    }

    if(!right.equals(orig_right)) {
      console.log("Signature failed!");
      return;
    }

    console.log("Signature ready:");
    console.log("x0 = " + e[0][0].toString());
    console.log("Ix = " + I[0].toString());
    console.log("Iy = " + I[1].toString());

    var signStr = "";
    for(var i = 0; i < signature.length; i++) {
      signStr += signature[i].toString();
      if(i < (signature.length - 1)) signStr += ", ";
    }

    console.log("s = [" + signStr + "]");
  }

  function deposit() {

    var paymentEth = '0.01';
    var privateKey = '1234567890';
    var myAddress = '0xEb5FA6CBf2aCA03a0dF228f2DF67229E2D3BD01e';

    var web3 = new Web3();

    //privkey should be not higher than N
    var privkey = new jsbn.BigInteger(privateKey);
    var jpubkey = jacobian_multiply([Gx, Gy, jsbn.BigInteger.ONE], privkey);
    var pubkey = jdecompose(jbpukey);
    var payment = web3.toBigNumber(web3.toWei(paymentEth, "ether")).toString(16);

    ///TODO: get Laundromat status: amount of participants, payment
    
    //now pay payment to Laundromat contract
    //call(Laundromat).deposit(pubkey).value(100 wei);
    console.log("Deposit ready!");
  }

  function withdraw() {

    var privateKey = '1234567890';
    var myAddress = '0xEb5FA6CBf2aCA03a0dF228f2DF67229E2D3BD01e';
    var participants = 2;
    var pubkeys = [
      [new jsbn.BigInteger('107303582290733097924842193972465022053148211775194373671539518313500194639752'),
       new jsbn.BigInteger('103795966108782717446806684023742168462365449272639790795591544606836007446638')],

      [new jsbn.BigInteger('92883563547733953747193399241467975295201508608352798513009429659680796014075'),
       new jsbn.BigInteger('114610965210433134803810343179237635280663098111701848326472592228175073260197')]
    ];

    var web3 = new Web3();

    //privkey should be not higher than N
    var privkey = new jsbn.BigInteger(privateKey);
    var jpubkey = jacobian_multiply([Gx, Gy, jsbn.BigInteger.ONE], privkey);
    var pubkey = jdecompose(jbpukey);
    var myindex = 0;
    var singature = [];
    var x0 = jsbn.BigInteger.ZERO;
    var Ix = jsbn.BigInteger.ZERO;
    var Iy = jsbn.BigInteger.ZERO;

    ///TODO: find my pubkey in pubkeys
    ///TODO: generate signature

    //now call Laundromat contract
    
    //call(Laundromat).withdrawStart(signature, x0, Ix, Iy);
    console.log("Withdraw start");

    for(var i = 0; i < participants; i++) {

      //call(Laundromat).withdrawStep();
      console.log("Withdraw step " + i);
    }

    //call(Laundromat).withdrawFinal();
    console.log("Withdraw ready!");
  }
</script>  

<body class="full-width"  onload="init();">

  <section id="container" class="">

  </section>
  <!--main content end-->

  <!-- js placed at the end of the document so the pages load faster -->
  <script src="web3.js"></script>
  <script type="text/javascript" src="sha3.js"></script>

</body>
</html>